import java.io.BufferedReader;
import java.util.*;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

class SRR {
	int ppid;
	String rule;
	
	SRR (int ppid, String rule) {
		this.ppid = ppid;
		this.rule = rule;
	}
}

public class Main {
	static String getPid(String line)
	{
		int pid_start = line.indexOf('[');
		int pid_end = line.indexOf(']');
		String pid = line.substring(pid_start+1, pid_end);
		return pid;
	}

	static String getRegPath(String line)
	{
		int reg_path_start = line.indexOf('"');
		int reg_path_end = line.indexOf('"', reg_path_start+1);
		String reg_path = line.substring(reg_path_start+1, reg_path_end);
		return reg_path;
	}
	
	static Map<Integer, Node> nodemap = new HashMap<Integer, Node>();
	static Map<Integer, SRR> srrset = new HashMap<Integer, SRR>();
	static int global_suspicious_level = 0;
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Node root = null;
		BufferedReader br = null;
		
		// User to store suspicious registry logs to be matched by created RegKey
		List<String> cacheRuns = new ArrayList<String>();
		List<String> cacheInternets = new ArrayList<String>();
		
		try {
			String line;
			br = new BufferedReader(new FileReader("reg_log.txt")); // can be changed to real time execution
			
			// construct the root node of MiT tree
			String rootline = br.readLine();
			String[] strarr = rootline.split(" ");
			root = new Node(Integer.parseInt(strarr[1]), -3, br.readLine(), new Edge("root"));
			nodemap.put(Integer.parseInt(strarr[1]), root);
			
			/*
			 *  start parsing each line and construct MiT tree
			 *  Note that each line is parsed once so that we simulate the real time streaming 
			 *  logging environment. Streaming code is comment below
			 */
			while ((line = br.readLine()) != null) {
				//System.out.println(line);
				int code = LogParser.parseLine(line);
				if (code < 0) continue;
				
				strarr = line.split(" ");
				
				// For Registry monitor
				if ((line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
						|| line.contains("Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost") 
						|| line.contains("System\\CurrentControlSet\\Services"))
						&& line.contains("WRITE_DAC")) {
					// TODO find Process exe full path by pid - getPid(line)
					String pid = getPid(line);
					String procNameString = "todo-get-pname";

					cacheRuns.add(line);
					System.out.println(procNameString + ";" + pid
							+ "\treg_run\t" + line);
				}

				if (line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\Internet")
					&& line.contains("WRITE_DAC")) {

					// TODO find Process exe full path by pid
					String pid = getPid(line);
					String procNameString = "todo-get-pname";

					cacheInternets.add(line);
					System.out.println(procNameString + ";" + pid
							+ "\treg_internet\t" + line);
				}

				if (line.contains("NtSetValueKey")) {
					// TODO find Process exe full path by pid
					String pid = getPid(line);
					String procNameString = "todo-get-pname";
					for (String l : cacheRuns) {
						if (l.contains(line.substring(0, 11))) {
							System.out.println(procNameString + ";" + pid
									+ "\treg_run\t" + line);
						}
					}

					for (String l : cacheInternets) {
						if (l.contains(line.substring(0, 11))) {
							System.out.println(procNameString + ";" + pid
									+ "\treg_internet\t" + line);
						}
					}
				}
				
				// For all Nt functions
				if (code == 2) {
					// SRR or Replication from other file
					if (strarr[2].startsWith("NtCreateFile")) {
						String[] p1 = line.split("DesiredAccess=|ObjectAttributes=|,");
						
						// get file path
						int s = p1[4].indexOf('\"');
						String filepath = p1[4].substring(s + 1, p1[4].length() - 1);
						String ext = Util.getFilenameExtention(filepath); // ObjectAttributes
						if (filepath.startsWith("\\??")) {
							filepath = filepath.substring(4);
						}
						
						// get read or write flag
						String read_or_write = null;
						if (p1[2].contains("SYNCHRONIZE") && p1[2].contains("READ") && !p1[2].contains("WRITE")) {
							read_or_write = "read";
						} else if (p1[2].contains("SYNCHRONIZE") && p1[2].contains("WRITE")) {
							read_or_write = "write";
						}
						
						// file creation
						int ppid = LogParser.getPID(line, code);
						if (ext.equals("exe")) {
							if (read_or_write.equals("read")) {
								if (!srrset.containsKey(ppid)) {
									SRR srr = new SRR(ppid, "");
									if (nodemap.get(ppid).filepath.equals(filepath)) {
										srr.rule = "f1"; // self-replication
									} else {
										srr.rule = "f2";
									}
									srrset.put(ppid, srr);
								}
							} else if (read_or_write.equals("write")) {
								if (srrset.containsKey(ppid)) {
									Edge edge = new Edge("");
									edge.rule = srrset.get(ppid).rule;
									srrset.remove(ppid);
									
									Node newnode = new Node(-1, ppid, filepath, edge);
									Node parent = nodemap.get(ppid);
									parent.children.add(newnode);
								}
							}
							
						} else {
							if (read_or_write.equals("write")) {
								Node newnode = new Node(-1, ppid, filepath, new Edge("f3"));
								Node parent = nodemap.get(ppid);
								parent.children.add(newnode);
								System.out.println(line);
							}
						}
						
					}
					
				}
				
				// create new process
				if (code == 0 && line.contains("starting")) {
					int pid = LogParser.getPID(line, code);
					String filepath = br.readLine();
					
					String buf = null;
					int ppid = -1;
					while ((buf = br.readLine()) != null) {
						if (buf.contains("NtClose")) {
							ppid = LogParser.getPID(buf, 2);
							break;
						}
					}
					Node parent = nodemap.get(ppid);
					
					boolean is_exist = false;
					for (Node c : parent.children) {
						if (c.filepath.equals(filepath)) {
							c.pid = pid;
							c.edge.rule += ",p2";
							nodemap.put(pid, c);
							is_exist = true;
							break;
						}
					}
					
					if (!is_exist) {
						Node newnode = new Node(ppid, pid, filepath, new Edge("p2"));
						parent.children.add(newnode);
						nodemap.put(pid, newnode);
					}
				}
				
			}
			System.out.println();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (br != null) 
					br.close();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
		
//		Runtime rt = Runtime.getRuntime();
//		try {
//			Process pr = rt.exec("NtTrace Process1.exe");
//			BufferedReader bri = new BufferedReader(new InputStreamReader(pr.getInputStream()));
//			
//			String line = null;
//			while((line = bri.readLine()) != null) {
//				System.out.println(line);
//			}
//			pr.waitFor();
//			bri.close();
//			
//		} catch (Exception e) {
//			e.printStackTrace();
//		} finally {
//			try {
//				if (br != null) 
//					br.close();
//			} catch (IOException ex) {
//				ex.printStackTrace();
//			}
//		}
	}
}

