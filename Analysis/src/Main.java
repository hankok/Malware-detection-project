import java.io.BufferedReader;
import java.util.*;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

class SRR {
	int ppid;
	String rule;
	
	SRR (int ppid, String rule) {
		this.ppid = ppid;
		this.rule = rule;
	}
}

class ProcessHelper {
	int ppid;
	boolean is_ready;
	
	ProcessHelper(int ppid, boolean is_ready) {
		this.ppid = ppid;
		this.is_ready = is_ready;
	}
}

class RegHelper {
	int ppid;
	String desired_access;
	String regpath;
	
	RegHelper(int ppid, String desired_access, String regpath) {
		this.ppid = ppid;
		this.desired_access = desired_access;
		this.regpath = regpath;
	}
	
}

public class Main {
	
	// Used to store malBehaviors, whenever mal behavior is detected
	static HashMap<String, HashSet<String>> malBehaviors = new HashMap<String, HashSet<String>>();
	
	static String getPid(String line)
	{
		int pid_start = line.indexOf('[');
		int pid_end = line.indexOf(']');
		String pid = line.substring(pid_start+1, pid_end);
		return pid.trim();
	}

	static String getRegPath(String line)
	{
		int reg_path_start = line.indexOf('"');
		int reg_path_end = line.indexOf('"', reg_path_start+1);
		String reg_path = line.substring(reg_path_start+1, reg_path_end);
		return reg_path.trim();
	}
	
	/*
	 * addMalBehavior - save behavior in the HashMap malBehaviors
	 * rule - one of these: p1/f1/p2/f2/p3/reg_run/reg_internet/tcp_fail/DNS_fail/terminate_other_or_ancestor_process
	 * malBehavior - description of malbehavior - e.g. process1.exe replicated process2.exe
	 * 
	 * When the malBehavior > 4, then pop up a messagebox, and returen true
	 * you will also need to print all the tree when addMalBehavior() returns true
	 * 
	 *  if(addMalBehavior(rule, malBehavior))
	 *  {
	 *  	print the mitree.
	 *  }
	 *  
	 */
	
	static boolean addMalBehavior(String rule, String malBehavior)
	{
		if (malBehaviors.get(rule) == null) {
			HashSet<String> malNodes = new HashSet<String>();
			malNodes.add(malBehavior);
			malBehaviors.put(rule, malNodes);
		} else {
			malBehaviors.get(rule).add(malBehavior);
		}

		if(malBehaviors.size() >= 4)
		{
			System.out.println("Highly Suspicious detected!");
			MessageBox.infoBox("Highly Suspicious behavior detected!", "Malware Alert");
			return true;
		}
		return false;
	}
	
	static Map<Integer, Node> nodemap = new HashMap<Integer, Node>();
	static Map<Integer, SRR> srrset = new HashMap<Integer, SRR>();
	static Map<String, RegHelper> regmap = new HashMap<String, RegHelper>();
	static int global_suspicious_level = 0;
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Node root = null;
		BufferedReader br = null;
		BufferedReader br_read_network_rslt = null;

		// Used to store suspicious registry logs to be matched by created RegKey
		List<String> cacheRuns = new ArrayList<String>();
		List<String> cacheInternets = new ArrayList<String>();

		try {
			String line;
			br = new BufferedReader(new FileReader("reg_log.txt")); // can be changed to real time execution
			
			// construct the root node of MiT tree
			String rootline = br.readLine();
			String[] strarr = rootline.split(" ");
			root = new Node(Integer.parseInt(strarr[1]), -3, br.readLine(), new Edge("root"));
			nodemap.put(Integer.parseInt(strarr[1]), root);

			// After a certain period, the while will be forced to break, here we set to 100 seconds
			// After the while breaks, the network log will be checked
			long start = System.currentTimeMillis();
			long end = start + 100*1000; // 100 seconds * 1000 ms/sec
			
			/*
			 *  start parsing each line and construct MiT tree
			 *  Note that each line is parsed once so that we simulate the real time streaming 
			 *  logging environment. Streaming code is comment below
			 */
			ProcessHelper ph = new ProcessHelper(-1, false);
			while ((line = br.readLine()) != null && System.currentTimeMillis() < end) {
				//System.out.println(line);
				int code = LogParser.parseLine(line);
				if (code < 0) continue;
				
				// For Registry monitor
				if ((line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
						|| line.contains("Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost") 
						|| line.contains("System\\CurrentControlSet\\Services"))
						&& line.contains("WRITE_DAC")) {
					// TODO find Process exe full path by pid - getPid(line)
					String pid = getPid(line);
					String procNameString = "todo-get-pname";

					cacheRuns.add(line);
					System.out.println(procNameString + ";" + pid + "\treg_run\t" + line);
				}

				if (line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\Internet")
					&& line.contains("WRITE_DAC")) {

					// TODO find Process exe full path by pid
					String pid = getPid(line);
					String procNameString = "todo-get-pname";

					cacheInternets.add(line);
					System.out.println(procNameString + ";" + pid+ "\treg_internet\t" + line);
				}

				if (line.contains("NtSetValueKey")) {
					String pid = getPid(line);
					String procNameString = "todo-get-pname";
					for (String l : cacheRuns) {
						if (l.contains(line.substring(0, 11))) {
							System.out.println(procNameString + ";" + pid
									+ "\treg_run\t" + line);
						}
					}

					for (String l : cacheInternets) {
						if (l.contains(line.substring(0, 11))) {
							System.out.println(procNameString + ";" + pid
									+ "\treg_internet\t" + line);
						}
					}
				}
				
				// For all Nt functions
				if (code == 2) {
					line = LogParser.preprocess(line);
					strarr = line.split(" ");
					
					// SRR or Replication from other file
					if (strarr[2].startsWith("NtCreateFile")) {
						String[] p1 = line.split("DesiredAccess=|ObjectAttributes=|,");
						
						// get file path
						int s = p1[4].indexOf('\"');
						String filepath = p1[4].substring(s + 1, p1[4].length() - 1);
						String ext = Util.getFilenameExtention(filepath); // ObjectAttributes
						if (filepath.startsWith("\\??")) {
							filepath = filepath.substring(4);
						}
						
						// get read or write flag
						String read_or_write = null;
						if (p1[2].contains("SYNCHRONIZE") && p1[2].contains("READ") && !p1[2].contains("WRITE")) {
							read_or_write = "read";
						} else if (p1[2].contains("SYNCHRONIZE") && p1[2].contains("WRITE")) {
							read_or_write = "write";
						}
						
						// file creation
						int ppid = LogParser.getPID(line, code);
						if (ext.equals("exe")) {
							if (read_or_write.equals("read")) {
								if (!srrset.containsKey(ppid)) {
									SRR srr = new SRR(ppid, "");
									if (nodemap.get(ppid).filepath.equals(filepath)) {
										srr.rule = "f1"; // potential self-replication
									} else {
										srr.rule = "f2"; // potential copy from other exe
									}
									srrset.put(ppid, srr);
								}
							} else if (read_or_write.equals("write")) { // commit
								if (srrset.containsKey(ppid)) {
									Edge edge = new Edge("");
									edge.rule = srrset.get(ppid).rule;
									srrset.remove(ppid);
									
									Node newnode = new Node(-1, ppid, filepath, edge);
									Node parent = nodemap.get(ppid);
									parent.children.add(newnode);
								}
							}
							
						} else { // non-exe file creation 
							if (read_or_write.equals("write")) {
								Node newnode = new Node(-1, ppid, filepath, new Edge("f3"));
								Node parent = nodemap.get(ppid);
								parent.children.add(newnode);
							}
						}
					}
										
					// dll or code injection
					if (strarr[2].startsWith("NtWriteVirtualMemory")) {
						int ppid = LogParser.getPID(line, code);
						if (nodemap.containsKey(ppid)) {
							Node parent = nodemap.get(ppid);
							Node newnode = new Node(-1, ppid, "injection-unknown", new Edge("p1"));
							parent.children.add(newnode);
						} else {
							// skip
						}
					}
					
					// process creation
					if (strarr[2].startsWith("NtCreateUserProcess")) {
						ph.ppid = LogParser.getPID(line, code);
						ph.is_ready = true;
					}
				
					// delete file
					if (strarr[2].startsWith("NtOpenFile")) {
						String[] p1 = line.split("DesiredAccess=|ObjectAttributes=|,");
						
						// get file path
						int s = p1[4].indexOf('\"');
						String filepath = p1[4].substring(s + 1, p1[4].length() - 1);
						if (filepath.startsWith("\\??")) {
							filepath = filepath.substring(4);
						}
						
						if (p1[2].startsWith("DELETE")) {
							boolean is_created = false;
							int ppid = LogParser.getPID(line, code);
							if (nodemap.containsKey(ppid)) {
								Node parent = nodemap.get(ppid);
								for (Node c : parent.children) {
									if (c.filepath.equals(filepath)) {
										c.edge.rule = "f4";
										is_created = true;
										break;
									}
								}
								// delete files note created by the process
								if (!is_created) {
									Node newnode = new Node(-1, ppid, filepath, new Edge("f4"));
									parent.children.add(newnode);
								}
								
							} 
						}
					}
					 
				}
				
				// create new process
				if (code == 0 && line.contains("starting") && ph.is_ready) {
					strarr = line.split(" ");
					int pid = LogParser.getPID(line, code);
					String filepath = br.readLine();

					if (nodemap.containsKey(ph.ppid)) {
						Node parent = nodemap.get(ph.ppid);
						boolean is_exist = false;
						for (Node c : parent.children) {
							if (c.filepath.equals(filepath)) {
								c.pid = pid;
								c.edge.rule += ",p2";
								nodemap.put(pid, c);
								is_exist = true;
								break;
							}
						}
						
						if (!is_exist) {
							Node newnode = new Node(pid, ph.ppid, filepath, new Edge("p2"));
							parent.children.add(newnode);
							nodemap.put(pid, newnode);
						}
					}
					ph.ppid = -1;
					ph.is_ready = false;
				}
			}
			
			// Wait until 100 seconds, until the network monitor stops 
			while(System.currentTimeMillis() < end)
			{
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			
			// Network: if any dns failure or tcp failure
			br_read_network_rslt = new BufferedReader(new FileReader("net_result")); // can be changed to real time execution
			String tcp_dns = br_read_network_rslt.readLine();
			if(tcp_dns.split(" ")[0].equals("1"))
			{
				System.out.println("Rootnode tcp_fail out.csv" );
			}
			
			if(tcp_dns.split(" ")[1].equals("1"))
			{
				System.out.println("Rootnode dns_fail dns.txt" );
			}	
			
			System.out.println();

		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (br != null) 
					br.close();
				if (br_read_network_rslt != null) 
					br_read_network_rslt.close();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
		
		System.out.println("Press Enter to continue");
		try{System.in.read();}
		catch(Exception e){}
		
//		Runtime rt = Runtime.getRuntime();
//		try {
//			Process pr = rt.exec("NtTrace Process1.exe");
//			BufferedReader bri = new BufferedReader(new InputStreamReader(pr.getInputStream()));
//			
//			String line = null;
//			while((line = bri.readLine()) != null) {
//				System.out.println(line);
//			}
//			pr.waitFor();
//			bri.close();
//			
//		} catch (Exception e) {
//			e.printStackTrace();
//		} finally {
//			try {
//				if (br != null) 
//					br.close();
//			} catch (IOException ex) {
//				ex.printStackTrace();
//			}
//		}
	}
}

