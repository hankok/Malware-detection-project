import java.io.BufferedReader;
import java.util.*;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;

class SRR {
	int ppid;
	String rule;
	
	SRR (int ppid, String rule) {
		this.ppid = ppid;
		this.rule = rule;
	}
}

class ProcessHelper {
	int ppid;
	boolean is_ready;
	
	ProcessHelper(int ppid, boolean is_ready) {
		this.ppid = ppid;
		this.is_ready = is_ready;
	}
}

public class Main {
	static Map<Integer, Node> nodemap = new HashMap<Integer, Node>();
	static Map<Integer, SRR> srrset = new HashMap<Integer, SRR>();
	// Used to store malBehaviors, whenever mal behavior is detected
	static HashMap<String, HashSet<String>> malBehaviors = new HashMap<String, HashSet<String>>();
	static String[] SUSPICIOUS_DEFINITION = {"f1", "f2", "f1,p2", "p1", "f4", "R", "S", "N"};
	static int suspicious_level = 0;
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		if (args.length != 1) {
			System.err.println("Main.main: 1 input argument is required!");
			return;
		}
		
		Node root = null;
		BufferedReader br = null;
		BufferedReader br_read_network_rslt = null;
		
		// Used to store suspicious registry logs to be matched by created RegKey
		List<String> cacheRuns = new ArrayList<String>();
		List<String> cacheInternets = new ArrayList<String>();
		
		// After a certain period, the while will be forced to break, here we set to 100 seconds
		// After the while breaks, the network log will be checked
		long start = System.currentTimeMillis();
		long end = start + Integer.parseInt(args[0]) * 1000; // 100 seconds * 1000 ms/sec
		boolean alert_flag = false;

		Runtime rt = Runtime.getRuntime();
		try {
			String line;
			br = new BufferedReader(new FileReader("1exe.txt")); // can be changed to real time execution
			//Process pr = rt.exec(new String[] {"NtTrace", "-pid", "-time", "-category", "File,Process,Registry,Memory", args[0]});
			//br = new BufferedReader(new InputStreamReader(System.in));
			
			// construct the root node of MiT tree
			String rootline = br.readLine();
			String[] strarr = rootline.split(" ");
			root = new Node(Integer.parseInt(strarr[1]), -3, br.readLine(), new Edge("root"));
			nodemap.put(Integer.parseInt(strarr[1]), root);
			
			// signature check
			if (!Util.isSigned(root.filepath)) {
			    addMalBehavior("S", root.filepath + ": no signature");
			}

			/*
			 *  start parsing each line and construct MiT tree
			 *  Note that each line is parsed once so that we simulate the real time streaming 
			 *  logging environment. Streaming code is comment below
			 */
			ProcessHelper ph = new ProcessHelper(-1, false);
			while ((line = br.readLine()) != null && System.currentTimeMillis() < end) {
				int code = LogParser.parseLine(line);
				if (code < 0) continue;
				
				String pid = getPid(line);
				// For Registry monitor
				if ((line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
						|| line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
						|| line.contains("Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost") 
						|| line.contains("System\\CurrentControlSet\\Services"))
						&& line.contains("WRITE_DAC")) {

					cacheRuns.add(line);
					addMalBehavior("R", nodemap.get(Integer.parseInt(pid)).filepath + "\t" + line);
					//System.out.println(nodemap.get(Integer.parseInt(pid)).filepath + "\t" + line);
				}

				if (line.contains("Software\\Microsoft\\Windows\\CurrentVersion\\Internet") && line.contains("WRITE_DAC")) {
					cacheInternets.add(line);
					addMalBehavior("R", nodemap.get(Integer.parseInt(pid)).filepath + "\t" + line);
					//System.out.println(nodemap.get(Integer.parseInt(pid)).filepath + "\t" + line);
				}

				if (line.contains("NtSetValueKey")) {
					for (String l : cacheRuns) {
						if (l.contains(line.substring(0, 11))) {
							addMalBehavior("R", nodemap.get(Integer.parseInt(pid)).filepath + "\t" + line);
							//System.out.println(nodemap.get(Integer.parseInt(pid)).filepath + "\t" + line);
						}
					}

					for (String l : cacheInternets) {
						if (l.contains(line.substring(0, 11))) {
							addMalBehavior("R", nodemap.get(Integer.parseInt(pid)).filepath + "\t" + line);
							// System.out.println(nodemap.get(Integer.parseInt(pid)).filepath + "\t" + line);
						}
					}
				}
				
				// For all Nt functions
				if (code == 2) {
					line = LogParser.preprocess(line);
					strarr = line.split(" ");
					
					// SRR or Replication from other file
					if (strarr[2].startsWith("NtCreateFile")) {
						String[] p1 = line.split("DesiredAccess=|ObjectAttributes=|,");
						
						// get file path
						int s = p1[4].indexOf('\"');
						String filepath = p1[4].substring(s + 1, p1[4].length() - 1);
						String ext = Util.getFilenameExtention(filepath); // ObjectAttributes
						if (filepath.startsWith("\\??")) {
							filepath = filepath.substring(4);
						}
						
						// get read or write flag
						String read_or_write = null;
						if (p1[2].contains("SYNCHRONIZE") && p1[2].contains("READ") && !p1[2].contains("WRITE")) {
							read_or_write = "read";
						} else if (p1[2].contains("SYNCHRONIZE") && p1[2].contains("WRITE")) {
							read_or_write = "write";
						}
						
						// file creation
						int ppid = LogParser.getPID(line, code);
						if (ext.equals("exe")) {
							if (read_or_write.equals("read")) {
								if (!srrset.containsKey(ppid)) {
									SRR srr = new SRR(ppid, "");
									if (nodemap.get(ppid).filepath.equals(filepath)) {
										srr.rule = "f1"; // potential self-replication
									} else {
										srr.rule = "f2"; // potential copy from other exe
									}
									srrset.put(ppid, srr);
								}
							} else if (read_or_write.equals("write")) { // commit
								if (srrset.containsKey(ppid)) {
									Edge edge = new Edge("");
									edge.rule = srrset.get(ppid).rule;
									srrset.remove(ppid);
									
									Node newnode = new Node(-1, ppid, filepath, edge);
									Node parent = nodemap.get(ppid);
									parent.children.add(newnode);
									
									if (edge.rule.equals("f1")) {
										addMalBehavior(edge.rule, parent.filepath + "\tPID:" + String.valueOf(ppid) 
										+ " Self-Repilcation:" + newnode.filepath);
									} else if (edge.rule.equals("f2")) {
										addMalBehavior(edge.rule, parent.filepath + "\tPID:" + String.valueOf(ppid) 
										+ " generates " + newnode.filepath);
									}
								}
							}
							
						} else { // non-exe file creation 
							if (read_or_write.equals("write")) {
								Node newnode = new Node(-1, ppid, filepath, new Edge("f3"));
								Node parent = nodemap.get(ppid);
								parent.children.add(newnode);
							}
						}
					}
										
					// dll or code injection
					if (strarr[2].startsWith("NtWriteVirtualMemory")) {
						int ppid = LogParser.getPID(line, code);
						if (nodemap.containsKey(ppid)) {
							Node parent = nodemap.get(ppid);
							Node newnode = new Node(-1, ppid, "injection-unknown", new Edge("p1"));
							parent.children.add(newnode);
							addMalBehavior("p1", parent.filepath + "\tPID:" + String.valueOf(ppid) 
							+ "Code_injection: " + newnode.filepath);
						} else {
							// skip
							
						}
					}
				
					// delete file
					if (strarr[2].startsWith("NtOpenFile")) {
						String[] p1 = line.split("DesiredAccess=|ObjectAttributes=|,");
						
						// get file path
						int s = p1[4].indexOf('\"');
						String filepath = p1[4].substring(s + 1, p1[4].length() - 1);
						if (filepath.startsWith("\\??")) {
							filepath = filepath.substring(4);
						}
						
						if (p1[2].startsWith("DELETE")) {
							boolean is_created = false;
							int ppid = LogParser.getPID(line, code);
							if (nodemap.containsKey(ppid)) {
								Node parent = nodemap.get(ppid);
								for (Node c : parent.children) {
									if (c.filepath.equals(filepath)) {
										c.edge.rule = "f4";
										is_created = true;
										break;
									}
								}
								// delete files not created by the process
								if (!is_created) {
									Node newnode = new Node(-1, ppid, filepath, new Edge("f4"));
									parent.children.add(newnode);
									addMalBehavior("f4", parent.filepath + "\tPID:" + String.valueOf(ppid) + " deleted " + newnode.filepath);
								}
								
							} 
						}
					}
					 
				}
				
				// process creation
				if (strarr[2].startsWith("NtCreateUserProcess")) {
					ph.ppid = LogParser.getPID(line, code);
					ph.is_ready = true;
				}
				
				// create new process
				if (code == 0 && line.contains("starting") && ph.is_ready) {
					strarr = line.split(" ");
					int pid_ = LogParser.getPID(line, code);
					String filepath = br.readLine();

					if (nodemap.containsKey(ph.ppid)) {
						Node parent = nodemap.get(ph.ppid);
						boolean is_exist = false;
						for (Node c : parent.children) {
							if (c.filepath.equals(filepath)) {
								// if the process is from SRR
								if (c.edge.rule.equals("f1")) {
									addMalBehavior("f1,p2", parent.filepath + "\tPID:" + String.valueOf(parent.pid) 
														+ " created_process: " + pid_ + ":" + c.filepath);
								}
								
								c.pid = pid_;
								c.edge.rule += ",p2";
								nodemap.put(pid_, c);
								is_exist = true;
								break;
							}
						}
						
						if (!is_exist) {
							Node newnode = new Node(pid_, ph.ppid, filepath, new Edge("p2"));
							parent.children.add(newnode);
							nodemap.put(pid_, newnode);
						}
					}
					ph.ppid = -1;
					ph.is_ready = false;
				}
				
				if (malBehaviors.size() >= 4 && !alert_flag) {
					System.out.println("Highly Suspicious detected!" + "Time elapsed: " + (System.currentTimeMillis() - start) + "ms");
					MessageBox.infoBox("Highly Suspicious: " + root.filepath + "!", "Malware Alert");
					System.out.println("User allowed continue running.");
					alert_flag = true;
				}
			}
			
//			// Wait until 100 seconds, until the network monitor stops 
//			while(System.currentTimeMillis() < end)
//			{
//				try {
//					Thread.sleep(1000);
//				} catch (InterruptedException e) {
//					e.printStackTrace();
//				}
//			}
//			
//			// Network: if any dns failure or tcp failure
//			br_read_network_rslt = new BufferedReader(new FileReader("net_result")); // can be changed to real time execution
//			String tcp_dns = br_read_network_rslt.readLine();
//			if(tcp_dns.split(" ")[0].equals("1"))
//			{
//				System.out.println("Rootnode tcp_fail out.csv" );
//			}
//			
//			if(tcp_dns.split(" ")[1].equals("1"))
//			{
//				System.out.println("Rootnode dns_fail dns.txt" );
//			}	
			
			// print tree table
			System.out.println("MiT tree table:\n" + root.toString() +
					"===============================================================");

			// print suspicious behavior
			System.out.println("Suspicious Behavior Report: ");
			for (String sb : SUSPICIOUS_DEFINITION) {
				if (malBehaviors.containsKey(sb)) {
					HashSet<String> e = malBehaviors.get(sb);
					Iterator<String> iter = e.iterator();
					while (iter.hasNext()) {
						System.out.println(iter.next());
					}
				}
			}
			System.out.println("Overall suspicious count: " + malBehaviors.size());
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (br != null) 
					br.close();
				if (br_read_network_rslt != null) 
					br_read_network_rslt.close();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
		
//		System.out.println("Press Enter to continue");
//		try{System.in.read();}
//		catch(Exception e){}
		
//		Runtime rt = Runtime.getRuntime();
//		try {
//			Process pr = rt.exec("NtTrace Process1.exe");
//			BufferedReader bri = new BufferedReader(new InputStreamReader(pr.getInputStream()));
//			
//			String line = null;
//			while((line = bri.readLine()) != null) {
//				System.out.println(line);
//			}
//			pr.waitFor();
//			bri.close();
//			
//		} catch (Exception e) {
//			e.printStackTrace();
//		} finally {
//			try {
//				if (br != null) 
//					br.close();
//			} catch (IOException ex) {
//				ex.printStackTrace();
//			}
//		}
	}
	
	static int getSuspiciousLevel() {
		int count = 0;
		for (String sb : SUSPICIOUS_DEFINITION) {
			if (malBehaviors.containsKey(sb)) {
				count++;
			}
		}
		return count;
	}
	
	static boolean addMalBehavior(String rule, String malBehavior)
	{
		if (malBehaviors.get(rule) == null) {
			HashSet<String> malNodes = new HashSet<String>();
			malNodes.add(malBehavior);
			malBehaviors.put(rule, malNodes);
		} else {
			malBehaviors.get(rule).add(malBehavior);
		}
		suspicious_level++;

//		if(malBehaviors.size() >= 4)
//		{
//			System.out.println("Highly Suspicious detected!");
//			MessageBox.infoBox("Highly Suspicious behavior detected!", "Malware Alert");
//			return true;
//		}
		return false;
	}
	
	static String getPid(String line)
	{
		int pid_start = line.indexOf('[');
		int pid_end = line.indexOf(']');
		if (pid_start >= pid_end) return "";
		String pid = line.substring(pid_start + 1, pid_end);
		return pid.trim();
	}

	static String getRegPath(String line)
	{
		int reg_path_start = line.indexOf('"');
		int reg_path_end = line.indexOf('"', reg_path_start+1);
		String reg_path = line.substring(reg_path_start+1, reg_path_end);
		return reg_path.trim();
	}
	
}

